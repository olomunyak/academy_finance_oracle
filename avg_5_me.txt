Plan hash value: 1846300850
 
--------------------------------------------------------------------------------------------
| Id  | Operation                       | Name     | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                |          |     1 |    51 |    21  (29)| 00:00:01 |
|   1 |  SORT ORDER BY                  |          |     1 |    51 |    21  (29)| 00:00:01 |
|   2 |   NESTED LOOPS                  |          |     1 |    51 |    20  (25)| 00:00:01 |
|   3 |    VIEW                         |          |     1 |    13 |    17  (30)| 00:00:01 |
|*  4 |     FILTER                      |          |       |       |            |          |
|   5 |      SORT AGGREGATE             |          |     1 |    40 |            |          |
|   6 |       NESTED LOOPS              |          |     8 |   320 |    17  (30)| 00:00:01 |
|*  7 |        HASH JOIN ANTI NA        |          |     1 |    36 |    14  (36)| 00:00:01 |
|   8 |         TABLE ACCESS FULL       | SALGRADE |     5 |    50 |     3   (0)| 00:00:01 |
|*  9 |         VIEW                    |          |     5 |   130 |    10  (40)| 00:00:01 |
|* 10 |          WINDOW SORT PUSHED RANK|          |     5 |    70 |    10  (40)| 00:00:01 |
|  11 |           HASH GROUP BY         |          |     5 |    70 |    10  (40)| 00:00:01 |
|  12 |            MERGE JOIN           |          |    42 |   588 |     8  (25)| 00:00:01 |
|  13 |             SORT JOIN           |          |     5 |    50 |     4  (25)| 00:00:01 |
|  14 |              TABLE ACCESS FULL  | SALGRADE |     5 |    50 |     3   (0)| 00:00:01 |
|* 15 |             FILTER              |          |       |       |            |          |
|* 16 |              SORT JOIN          |          |    14 |    56 |     4  (25)| 00:00:01 |
|  17 |               TABLE ACCESS FULL | EMP      |    14 |    56 |     3   (0)| 00:00:01 |
|* 18 |        TABLE ACCESS FULL        | EMP      |     8 |    32 |     3   (0)| 00:00:01 |
|* 19 |    TABLE ACCESS FULL            | EMP      |     1 |    38 |     3   (0)| 00:00:01 |
--------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   4 - filter(1=1)
   7 - access("S"."GRADE"="G"."GRADE")
   9 - filter("RNK"=1)
  10 - filter(RANK() OVER ( ORDER BY COUNT(*) DESC )<=1)
  15 - filter("E"."SAL"<="S"."HISAL")
  16 - access("E"."SAL">="S"."LOSAL")
       filter("E"."SAL">="S"."LOSAL")
  18 - filter("E"."SAL">="S"."LOSAL" AND "E"."SAL"<="S"."HISAL")
  19 - filter("E"."SAL">="SA"."RESAL")


데이터량이 작으면 작을수록 데이터 사이즈가 작아진다.
단계가 작으면 작을수록 효율이 올라간다.
데이터량이 많아지는 시점에서 효율을 고려해서 짜주면 된다.
사이즈가 작으면 티가 안 나는데 커지면 커질수록 읽어지는 속도가 느려진다.
CPU사용량이 폭증하는 곳을 보면 된다. 그 쪽이 쿼리가 잘못된 것이다.

실행계획하고 같이 봐야 한다.
갑자기 뭔가 늘어났다고 하면은 머지조인이 문제가 생긴 것이다.
 데이터 사이즈가 작으면 속도가 느린지 빠른지 확인할수 없다.
머지조인 - 합쳐서 조인을 한다. 결론은 다 머지조인이다.

rows - 에서 조건을 제대로 맞춰서 걸면 제대로 나온다. 값이 많이 나오면
      조건을 잘못 걸었다는 것이다.
소트조인과 머지조인의 차이는 소트는 그냥 소트다.

효율을 분석할때는 차례대로 다 보면 된다.

---
제일안쪽 쿼리는 문제가 없다.
문제는 평균을 낸 부분이다.

---
쿼리를 짤때 중요한 것은 데이터 사이즈를 고려해야 한다.
백만 * 백만 --> 1조 개로 는다.

가끔 걸었는데 문제가 올 경우.. 테이블에 인덱스가 안 걸린 거다.


쿼리점검할때
실행계획 , explain plan for

----

친구신청할때 데이터가 이중으로 들어가게 되었다.
알 수도 있는 친구 까지 생각할 경우 데이터가 n승으로 올라간다.
고작 4000건의 데이터에서 부서끼리만 친구를 맺어 줬는데 삼천만건이 나왔다.
그 삼천만건 안에서 내가 알 수도 있는 친구 까지 뽑아 와야 했다.
최초 쿼리를 짰을때 정보를 뽑아오는데만(실행시간이) 10분이 걸렸다.

===>
테이블에다 인덱스를 걸었다.
10분에서 3분으로 줄었다.

서브쿼리를 제거하고 안쪽쿼리를 다시 짰다.
0.89초가 걸렸다.

속도적인 문제는 찾으면 되지만 간단한것 만으로도 많이 빨라진다.
3분에서 0.89초를 만들려고 수백번 수천번 수정을 했다.

쿼리는 짜놓고 문제를 찾아가는 것이다.
결과를 나놓고 속도를 줄여간다. (일단 해놓고 나서 수정을 한다.) 
마감시간을 지키고 속도를 고려한다.